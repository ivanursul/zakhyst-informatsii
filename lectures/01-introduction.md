# Лекція 1. Вступ. Проблема довіри в інтернеті

## Зміст

1. [Вступ до захисту інформації](#1-вступ-до-захисту-інформації)
2. [Проблема довіри в інтернеті](#2-проблема-довіри-в-інтернеті)
3. [Identity, Authentication, Authorization](#3-identity-authentication-authorization)
4. [Історія механізмів автентифікації](#4-історія-механізмів-автентифікації)
5. [Threat Modeling: модель STRIDE](#5-threat-modeling-модель-stride)
6. [Підсумки](#6-підсумки)

---

## 1. Вступ до захисту інформації

### Чому це важливо?

Кожного дня мільярди людей взаємодіють з інтернет-сервісами: перевіряють пошту, здійснюють банківські операції, обмінюються повідомленнями, зберігають документи у хмарі. За кожною такою дією стоїть фундаментальне питання: **як система може впевнитися, що ви — це ви?**

Захист інформації — це не лише про шифрування чи паролі. Це комплексна дисципліна, яка охоплює:

- **Конфіденційність** (Confidentiality) — доступ до інформації мають лише уповноважені особи
- **Цілісність** (Integrity) — гарантія, що дані не були змінені або підроблені під час передачі чи зберігання; отримувач отримує саме те, що відправив відправник
- **Доступність** (Availability) — інформація доступна, коли це потрібно

Ця тріада відома як **CIA Triad** і є основою будь-якої системи інформаційної безпеки.

### Про цей курс

Цей курс побудований навколо протоколу **OAuth 2.0** як центральної осі. OAuth — це не просто «логін через Google». Це фреймворк авторизації, через який ми розкриємо всі ключові концепції захисту інформації:

- Криптографічні примітиви (хешування, шифрування, підписи)
- Протоколи автентифікації та авторизації
- Безпека веб-додатків та мікросервісів
- Моделювання загроз

Кожна тема мотивована **практичною потребою** — спочатку проблема, потім інструмент.

---

## 2. Проблема довіри в інтернеті

### Від реального світу до цифрового

У реальному світі довіра будується на фізичних речах: ви показуєте паспорт, підписуєте документ від руки, впізнаєте знайомого по обличчю. В інтернеті жоден із цих механізмів не працює безпосередньо.

Коли ви заходите на сайт банку, виникає ланцюжок питань:

1. **Чи справжній цей сайт?** (Проблема автентичності сервера)
2. **Чи справжній цей користувач?** (Проблема автентифікації клієнта)
3. **Чи має цей користувач право виконати цю дію?** (Проблема авторизації)
4. **Чи не було перехоплено дані по дорозі?** (Проблема конфіденційності каналу)
5. **Чи не підмінив хтось дані?** (Проблема цілісності)

### Проблема делегування доступу

Уявіть типовий сценарій: Максим Витребенько хоче, щоб сервіс друку фотографій отримав доступ до його фото в Google Photos. Як це зробити?

**Наївний підхід:** Максим дає сервісу друку свій логін і пароль від Google. Проблеми очевидні:
- Сервіс отримує **повний доступ** до вашого акаунту, а не лише до фото
- Ви не можете **відкликати** доступ без зміни пароля
- Якщо сервіс друку зламають, зламають і ваш Google-акаунт
- Ви **не контролюєте**, що саме робить сервіс від вашого імені

Саме цю проблему вирішує **OAuth 2.0** — протокол делегованої авторизації, який дозволяє надати обмежений доступ до ресурсів без передачі credentials.

### Модель загроз у мережі

Протоколи безпеки проєктуються з урахуванням моделі загроз. У контексті інтернету ми зазвичай припускаємо існування **активного атакуючого** (active adversary), який може:

- **Перехоплювати** мережевий трафік (eavesdropping)
- **Модифікувати** повідомлення в транзиті (tampering)
- **Повторно відправляти** перехоплені повідомлення (replay attack)
- **Видавати себе** за іншу сторону (impersonation)

Кожен механізм, який ми вивчатимемо в цьому курсі, є відповіддю на одну або кілька з цих загроз.

---

## 3. Identity, Authentication, Authorization

Три фундаментальні концепції, які часто плутають, але які принципово різні.

### Identity (Ідентичність)

**Identity** — це набір атрибутів, що описують сутність (користувача, сервіс, пристрій) у системі.

Приклади identity:
- Ім'я користувача: `maksym.vytrebenko`
- Email: `maksym.vytrebenko@example.com`
- ID у системі: `user-12345`
- Сертифікат X.509 сервера

Identity відповідає на питання: **"Хто це?"**

Один користувач може мати **кілька identity** в різних системах. Наприклад, Google-акаунт, GitHub-акаунт, корпоративний акаунт — це різні identity однієї людини.

### Authentication (Автентифікація)

**Authentication** — це процес підтвердження identity. Тобто доказ того, що сутність є тим, за кого себе видає.

Фактори автентифікації:

| Фактор | Опис | Приклад |
|--------|------|---------|
| **Something you know** | Щось, що знаєте лише ви | Пароль, PIN-код, секретне питання |
| **Something you have** | Щось, що маєте лише ви | Телефон (SMS/TOTP), YubiKey, смарт-картка |
| **Something you are** | Щось, що є частиною вас | Відбиток пальця, Face ID, сітківка ока |

**Multi-Factor Authentication (MFA)** — використання двох або більше факторів одночасно. Наприклад: пароль (know) + код з телефону (have).

MFA суттєво підвищує безпеку, бо компрометація одного фактора не дає доступу до системи.

### Authorization (Авторизація)

**Authorization** — це процес визначення, які дії дозволено виконувати автентифікованій сутності.

Автентифікація завжди передує авторизації: спочатку система впевнюється, хто ви, а потім вирішує, що вам дозволено.

Моделі авторизації:

- **ACL (Access Control List)** — список дозволів для кожного ресурсу
- **RBAC (Role-Based Access Control)** — дозволи прив'язані до ролей
- **ABAC (Attribute-Based Access Control)** — рішення на основі атрибутів
- **OAuth 2.0 Scopes** — обмеження доступу через scopes (read, write, admin)

### Порівняння

```
┌─────────────────────────────────────────────────────────┐
│                    Запит користувача                     │
└──────────────────────────┬──────────────────────────────┘
                           │
                           ▼
              ┌────────────────────────┐
              │   IDENTIFICATION       │
              │   "Хто ви?"            │
              │   → username: maksym   │
              └───────────┬────────────┘
                          │
                          ▼
              ┌────────────────────────┐
              │   AUTHENTICATION       │
              │   "Доведіть це"        │
              │   → password: ****     │
              │   → 2FA code: 123456   │
              └───────────┬────────────┘
                          │
                          ▼
              ┌────────────────────────┐
              │   AUTHORIZATION        │
              │   "Що вам дозволено?"  │
              │   → role: editor       │
              │   → scopes: read,write │
              └────────────────────────┘
```

---

## 4. Історія механізмів автентифікації

Розуміння еволюції допомагає зрозуміти, **чому** OAuth виглядає саме так.

### 4.1. HTTP Basic Authentication

**RFC 7617.** Найпростіший механізм автентифікації в HTTP.

Як працює:
1. Клієнт відправляє запит
2. Сервер відповідає `401 Unauthorized` з заголовком `WWW-Authenticate: Basic`
3. Клієнт кодує `username:password` в Base64 і відправляє в заголовку:

```http
GET /api/data HTTP/1.1
Authorization: Basic bWFrc3ltOnN1cGVyc2VjcmV0
```

Base64 — це **кодування**, а не шифрування. Будь-хто може декодувати рядок назад:

```
bWFrc3ltOnN1cGVyc2VjcmV0  →  base64 decode  →  maksym:supersecret
```

Тобто credentials передаються фактично у відкритому вигляді. Достатньо виконати `echo "bWFrc3ltOnN1cGVyc2VjcmV0" | base64 -d`, щоб отримати логін і пароль.

**Проблеми:**
- Credentials передаються з **кожним запитом** і легко декодуються з Base64
- Без HTTPS credentials можна перехопити в plain text
- Немає механізму **logout** — браузер кешує credentials
- Немає **делегування** — неможливо дати обмежений доступ третій стороні
- Немає **гранулярності** — або повний доступ, або нічого

```
┌──────────┐                         ┌──────────┐
│  Client  │──── GET /resource ─────→│  Server  │
│          │←── 401 Unauthorized ────│          │
│          │                         │          │
│          │──── GET /resource ─────→│          │
│          │     Authorization:      │          │
│          │     Basic base64(u:p)   │          │
│          │←── 200 OK ─────────────│          │
└──────────┘                         └──────────┘

⚠️ Credentials відправляються з КОЖНИМ запитом
```

### 4.2. Session-based Authentication (Сесії)

**Еволюційна відповідь** на проблеми Basic Auth.

Як працює:
1. Клієнт відправляє credentials **один раз** (POST /login)
2. Сервер створює сесію, зберігає її стан у пам'яті/БД
3. Сервер повертає **Session ID** у cookie
4. Наступні запити містять лише Session ID, а не credentials

```http
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=ivan&password=secret123

HTTP/1.1 200 OK
Set-Cookie: session_id=abc123; HttpOnly; Secure; Path=/
```

```
┌──────────┐                         ┌──────────┐      ┌──────────────┐
│  Client  │──── POST /login ───────→│  Server  │─────→│ Session Store│
│          │     (credentials)       │          │      │ abc123: {    │
│          │←── Set-Cookie: ────────│          │      │   user: ivan │
│          │    session_id=abc123    │          │      │   role: admin│
│          │                         │          │      │ }            │
│          │──── GET /resource ─────→│          │─────→│              │
│          │     Cookie: abc123      │          │ lookup│              │
│          │←── 200 OK ─────────────│          │←─────│              │
└──────────┘                         └──────────┘      └──────────────┘
```

**Переваги перед Basic Auth:**
- Credentials передаються лише один раз
- Сесію можна завершити (logout) — видалити з session store
- Можна зберігати стан (role, permissions, last activity)

**Проблеми:**
- **Stateful** — сервер повинен зберігати стан кожної сесії
- **Масштабування** — при кількох серверах потрібне спільне сховище сесій (Redis, БД)
- **CSRF (Cross-Site Request Forgery)** — браузер автоматично додає cookies до **кожного** запиту на домен, навіть якщо запит ініційований зловмисним сайтом. Наприклад, якщо користувач залогінений у банку (`bank.com`), зловмисний сайт може вставити приховану форму `<form action="https://bank.com/transfer">` — і браузер автоматично додасть session cookie, виконавши переказ від імені користувача без його відома
- **Cross-domain** — cookies прив'язані до конкретного домену (Same-Origin Policy). Якщо ваш фронтенд на `app.example.com`, а API на `api.example.com` — cookie від одного домену не буде відправлений на інший. Це робить сесії непридатними для архітектур, де клієнт і сервер живуть на різних доменах (типова ситуація для SPA + REST API)
- Все ще **немає делегування** доступу

### 4.3. Token-based Authentication (Токени)

**Ключовий зсув: від stateful до stateless.**

Головна відмінність від сесій: при сесійному підході сервер зберігає стан (хто залогінений, з якими правами) у себе, а клієнту дає лише ідентифікатор (Session ID). При токенах — навпаки: **вся інформація зберігається в самому токені** (ім'я, роль, права, термін дії), а сервер нічого не зберігає. Сервер лише перевіряє цифровий підпис токена при кожному запиті.

Ідея: замість зберігання сесії на сервері, вся необхідна інформація міститься в **токені**, який клієнт зберігає та відправляє з кожним запитом.

```http
GET /api/data HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

```
┌──────────┐                         ┌──────────┐
│  Client  │──── POST /login ───────→│  Server  │
│          │     (credentials)       │          │
│          │←── { token: "eyJ..." }─│          │ Генерує підписаний
│          │                         │          │ токен (JWT)
│          │──── GET /resource ─────→│          │
│          │     Authorization:      │          │ Верифікує підпис
│          │     Bearer eyJ...       │          │ (без БД!)
│          │←── 200 OK ─────────────│          │
└──────────┘                         └──────────┘

✅ Сервер НЕ зберігає стан — все в токені
```

**Переваги:**
- **Stateless** — сервер не зберігає стан, легко масштабувати
- **Cross-domain** — токен передається в заголовку, не обмежений доменом
- **Self-contained** — токен містить всю інформацію (claims)
- **Верифікація без БД** — достатньо перевірити цифровий підпис

**Проблеми:**
- **Revocation (відкликання)** — оскільки сервер не зберігає стан, він не може «забути» виданий токен. Якщо токен скомпрометований (вкрадений), він залишається дійсним до закінчення терміну дії (`exp`). Для сесій це просто — видаляємо запис з session store. Для токенів потрібні додаткові механізми: blacklist, short-lived tokens + refresh tokens
- **Розмір** — JWT токен значно більший за Session ID (сотні байт замість десятків)
- **Зберігання** — де зберігати токен на клієнті (localStorage? cookie?) — кожен варіант має свої вразливості
- Все ще **немає стандартного протоколу делегування**

### 4.4. OAuth 2.0

**Відповідь на проблему делегування доступу.**

Basic Auth, сесії та токени вирішують питання «як підтвердити, хто я?» — але жоден з них не відповідає на питання «як дати комусь **обмежений** доступ до **моїх** ресурсів, не передаючи свій пароль?». OAuth 2.0 — це принципово інший рівень: це не механізм автентифікації, а **фреймворк авторизації**, який розділяє ролі (хто дає доступ, хто просить, хто перевіряє) і дозволяє гранулярно контролювати, що саме дозволено.

OAuth 2.0 (RFC 6749, 2012) дозволяє стороннім додаткам отримати обмежений доступ до ресурсів користувача **без передачі credentials**.

```
┌──────────┐                                          ┌─────────────────┐
│ Resource │                                          │  Authorization  │
│  Owner   │                                          │     Server      │
│ (User)   │                                          │  (Google, etc.) │
└────┬─────┘                                          └───────┬─────────┘
     │                                                        │
     │  1. "Хочу друкувати мої фото"                         │
     │                                                        │
     ▼                                                        │
┌──────────┐                                                  │
│  Client  │  2. Redirect → Authorization Server              │
│ (Сервіс  │─────────────────────────────────────────────────→│
│  друку)  │                                                  │
└──────────┘                                                  │
                                                              │
     ┌────────────────────────────────────────────────────────│
     │  3. "Дозволити сервісу друку читати ваші фото?"       │
     ▼                                                        │
┌──────────┐                                                  │
│ Resource │  4. "Так, дозволяю" (consent)                    │
│  Owner   │─────────────────────────────────────────────────→│
└──────────┘                                                  │
                                                              │
┌──────────┐  5. Authorization Code                           │
│  Client  │←─────────────────────────────────────────────────│
│          │                                                  │
│          │  6. Code → Token Exchange                        │
│          │─────────────────────────────────────────────────→│
│          │                                                  │
│          │  7. Access Token (scope: photos.read)            │
│          │←─────────────────────────────────────────────────│
│          │                                                  │
│          │  8. GET /photos (Bearer token)                   │
│          │─────────────────────────────────────────────────→│ Resource
│          │                                                  │ Server
│          │  9. Фото                                         │
│          │←─────────────────────────────────────────────────│
└──────────┘
```

**Ключові ролі OAuth 2.0:**

| Роль | Опис | Приклад |
|------|------|---------|
| **Resource Owner** | Власник ресурсів | Ви (ваші фото) |
| **Client** | Додаток, що запитує доступ | Сервіс друку |
| **Authorization Server** | Видає токени після авторизації | Google OAuth |
| **Resource Server** | Зберігає захищені ресурси | Google Photos API |

**Що дає OAuth:**
- Користувач **не передає пароль** сторонньому сервісу
- Доступ обмежений **scopes** (наприклад, тільки читання фото)
- Доступ можна **відкликати** в будь-який момент
- **Стандартизований протокол** — працює однаково у всіх провайдерів

### Порівняльна таблиця

| Характеристика | Basic Auth | Сесії | Токени | OAuth 2.0 |
|----------------|:---------:|:-----:|:------:|:---------:|
| Credentials з кожним запитом | так | — | — | — |
| Stateless (без стану на сервері) | так | ні | так | так |
| Можливість logout | ні | так | складно | так |
| Робота між доменами | ні | ні | так | так |
| Делегування доступу третім сторонам | ні | ні | ні | **так** |
| Гранулярний контроль (scopes) | ні | обмежено | обмежено | **так** |
| Стандартизація | RFC 7617 | — | часткова | **RFC 6749** |

> «так» = механізм підтримує цю можливість, «ні» = не підтримує, «—» = не застосовується

---

## 5. Threat Modeling: модель STRIDE

### Навіщо моделювати загрози?

Threat modeling — це систематичний підхід до визначення загроз безпеці системи. Замість того, щоб реагувати на атаки post factum, ми **проактивно** шукаємо вразливості ще на етапі проєктування.

Питання, які задає threat modeling:
1. **Що ми будуємо?** (Опис системи)
2. **Що може піти не так?** (Ідентифікація загроз)
3. **Що ми з цим зробимо?** (Mitigation)
4. **Чи достатньо ми зробили?** (Validation)

### Модель STRIDE

**STRIDE** — це модель класифікації загроз, розроблена Microsoft. Кожна літера — це категорія загрози:

| Загроза | Опис | Порушує | Приклад |
|---------|------|---------|---------|
| **S** — Spoofing | Видання себе за іншого | Authentication | Фішинговий сайт, що імітує банк |
| **T** — Tampering | Несанкціонована зміна даних | Integrity | Модифікація JWT payload без підпису |
| **R** — Repudiation | Заперечення виконаних дій | Non-repudiation | Користувач заперечує, що робив транзакцію |
| **I** — Information Disclosure | Витік конфіденційних даних | Confidentiality | Перехоплення токенів через HTTP (без TLS) |
| **D** — Denial of Service | Відмова в обслуговуванні | Availability | DDoS-атака на Authorization Server |
| **E** — Elevation of Privilege | Підвищення привілеїв | Authorization | Зміна scope в токені з `read` на `admin` |

### STRIDE у контексті OAuth 2.0

Застосуємо STRIDE до типової OAuth-системи:

#### S — Spoofing (Підробка ідентичності)
- **Загроза:** зловмисник реєструє фішинговий Client, що виглядає як легітимний
- **Загроза:** підробка redirect_uri для перехоплення authorization code
- **Mitigation:** суворо валідувати redirect_uri, використовувати client_secret

#### T — Tampering (Підробка даних)
- **Загроза:** модифікація authorization code під час передачі
- **Загроза:** зміна claims в JWT токені
- **Mitigation:** цифрові підписи (RS256, ES256), HTTPS

#### R — Repudiation (Заперечення)
- **Загроза:** клієнт заперечує, що запитував певний scope
- **Mitigation:** логування всіх authorization requests, audit trail

#### I — Information Disclosure (Витік інформації)
- **Загроза:** токени передаються через URL і потрапляють у логи/referrer
- **Загроза:** access token витікає через browser history
- **Mitigation:** використовувати authorization code (back-channel), не передавати токени через URL

#### D — Denial of Service
- **Загроза:** flood запитами на token endpoint
- **Mitigation:** rate limiting, CAPTCHA на consent screen

#### E — Elevation of Privilege (Підвищення привілеїв)
- **Загроза:** клієнт запитує scope ширший, ніж дозволено
- **Загроза:** модифікація access token для розширення прав
- **Mitigation:** суворо валідувати scopes, підписувати токени

### Практичне застосування STRIDE

Для кожної системи, яку ми будуватимемо в цьому курсі, ми будемо проходити через наступні кроки:

1. **Намалювати DFD (Data Flow Diagram)** — діаграму потоків даних. DFD — це графічна модель системи, яка показує, як дані переміщуються між зовнішніми сутностями (External Entity — користувачі, зовнішні сервіси), процесами (Process — логіка обробки), сховищами даних (Data Store — бази даних, файли) та каналами передачі (Data Flow — HTTP-запити, повідомлення). Кожен з цих елементів має свій набір характерних загроз
2. **Для кожного елемента DFD** — застосувати STRIDE
3. **Для кожної загрози** — визначити ймовірність та вплив
4. **Обрати стратегію** — Mitigate (виправити), Accept (прийняти), Transfer (передати), Avoid (уникнути)

```
┌─────────────────────────────────────────────────────┐
│                   DFD елементи                       │
├──────────────────┬──────────────────────────────────┤
│  External Entity │  → S, R                          │
│  Process         │  → S, T, R, I, D, E              │
│  Data Store      │  → T, R, I, D                    │
│  Data Flow       │  → T, I, D                       │
└──────────────────┴──────────────────────────────────┘
```

---

## 6. Підсумки

### Що ми розглянули

- **CIA Triad** — конфіденційність, цілісність, доступність як основа захисту інформації
- **Проблема довіри** — в інтернеті неможливо довіряти жодній стороні за замовчуванням
- **Identity vs Authentication vs Authorization** — три різні концепції, що працюють разом
- **Еволюція автентифікації**: Basic Auth → Sessions → Tokens → OAuth 2.0
- **STRIDE** — систематичний підхід до моделювання загроз

### Ключові висновки

1. OAuth 2.0 вирішує проблему **делегованого доступу**, яку не вирішував жоден попередній механізм
2. Кожен наступний механізм автентифікації виник як відповідь на **обмеження попереднього**
3. Threat modeling — це не одноразова вправа, а **безперервний процес**, що супроводжує весь lifecycle системи
4. Безпека — це завжди **компроміс** між зручністю та захистом

### Що далі?

У наступній лекції ми зануримося в **криптографічні примітиви** — хешування та цілісність даних:

- **SHA-256** (Secure Hash Algorithm, 256 біт) — криптографічна хеш-функція, яка перетворює довільні дані у фіксований 256-бітний «відбиток»
- **bcrypt** та **Argon2** — спеціалізовані алгоритми для хешування паролів, стійкі до brute-force атак
- **Ентропія** та **CSPRNG** (Cryptographically Secure Pseudo-Random Number Generator) — як генерувати по-справжньому випадкові значення для токенів та ключів
- **HMAC** (Hash-based Message Authentication Code) — механізм перевірки цілісності та автентичності повідомлень на основі хеш-функції та секретного ключа
- **Rainbow tables** та **salting** — атака на хеші через заздалегідь обчислені таблиці та захист від неї

Ці примітиви є фундаментом, на якому побудовані всі механізми безпеки, включаючи OAuth 2.0.

---

## Література

1. Eduardo Fernandez-Buglioni. *Security patterns in practice.* — Wiley: 2013
2. Loren Kohnfelder. *Designing Secure Software.* — No Starch Press: 2021
3. Adam Shostack. *Threat Modeling: Designing for Security.* — Wiley: 2014
4. RFC 6749 — The OAuth 2.0 Authorization Framework
